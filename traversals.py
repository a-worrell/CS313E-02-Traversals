"""
Student information for this assignment:

Replace <FULL NAME> with your name.
On my honor, Audrey Worrell, this 
programming assignment is my own work and I have not provided this code to 
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: ACW3428
UT EID 2:
"""


# Iterates over a 2D list from left to right, then top to bottom
# and returning the coordinates (row, column).
def row_major_traversal(grid):
    row = 0
    loc = []
    while row < len(grid):
        col = 0
        while col < len(grid[row]):
            loc.append((row, col))
            col += 1
        row += 1
    return loc


# Iterates over a 2D list from left to right, then top to bottom
# and returning the coordinates (row, column).
def column_major_traversal(grid):
    col = 0
    loc = []
    while col < len(grid[0]):
        row = 0
        while row < len(grid):
            loc.append((row, col))
            row += 1
        col += 1
    return loc


# Iterates over a 2D list from top to bottom then left to right
# and returning the coordinates (row, column).
def row_zigzag_traversal(grid):
    row = 0
    loc = []
    while row < len(grid):
        if row%2 == 0:
            col = 0
            while col < len(grid[row]):
                loc.append((row, col))
                col += 1
        else:
            col = len(grid[row]) - 1
            while col >= 0:
                loc.append((row, col))
                col -= 1
        row += 1
    return loc


# Iterates over a 2D list by alternating between iterating
# left to right and right to left, going from top to bottom
# and returning the coordinates (row, column).
def column_zigzag_traversal(grid):
    col = 0
    loc = []
    while col < len(grid[0]):
        if col%2 == 0:
            row = 0
            while row < len(grid):
                loc.append((row, col))
                row += 1
        else:
            row = len(grid) - 1
            while row >= 0:
                loc.append((row, col))
                row -= 1
        col += 1
    return loc


# Iterates over a 2D list from the top-right to the bottom-left
# in the direction of the main diagonal and returning the
# coordinates (row, column).
def main_diagonal_traversal(grid):
    col = len(grid[0]) - 1
    row = 0
    loc = []
    while row < len(grid):
        sRow = row
        while col >= 0:
            sCol = col
            row = sRow
            while col < len(grid[0]) and row < len(grid):
                loc.append((row, col))
                row += 1
                col += 1
            col = sCol - 1
        col = 0
        row = sRow + 1
    return loc


# Iterates over a 2D list from the top-left to the bottom-right
# in the direction of the secondary diagonal and returning the
# coordinates (row, column).
def secondary_diagonal_traversal(grid):
    col = 0
    row = 0
    loc = []
    while row < len(grid):
        sRow = row
        while col < len(grid[0]):
            sCol = col
            row = sRow
            while col >= 0 and row < len(grid):
                loc.append((row, col))
                row += 1
                col -= 1
            col = sCol + 1
        col = len(grid[0]) - 1
        row = sRow + 1
    return loc


# Iterates over a 2D list in spiral order and returning the
# coordinates (row, column).
def spiral_traversal(grid):
    row = 0
    col = 0
    round = 0
    loc = []
    print(len(grid) * len(grid[0]))
    while row < len(grid) - round:
        print(row, col, round, len(grid[0])-round)
        while col < len(grid[0]) - round and len(loc) < len(grid) * len(grid[0]):
            loc.append((row, col))
            col += 1
        col -= 1
        row += 1
        while row < len(grid) - round and len(loc) < len(grid) * len(grid[0]):
            loc.append((row, col))
            row += 1 
        row -= 1
        col -= 1
        while col > 0 + round and len(loc) < len(grid) * len(grid[0]):
            loc.append((row, col))
            col -= 1
        while row > 0 + round and len(loc) < len(grid) * len(grid[0]):
            loc.append((row, col))
            row -= 1
        row += 1
        col += 1
        round += 1
    return loc
    


grid_3x5 = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]
##print("C", column_major_traversal(grid_3x5))
#print("RZ", row_zigzag_traversal(grid_3x5))
#print("CZ", column_zigzag_traversal(grid_3x5))
#print("MD", main_diagonal_traversal(grid_3x5))
#print("SD", secondary_diagonal_traversal(grid_3x5))
#print("ST", spiral_traversal(grid_3x5))


grid_8x6 = [
            [1, 2, 3, 4, 5, 6],
            [7, 8, 9, 10, 11, 12],
            [13, 14, 15, 16, 17, 18],
            [19, 20, 21, 22, 23, 24],
            [25, 26, 27, 28, 29, 30],
            [31, 32, 33, 34, 35, 36],
            [37, 38, 39, 40, 41, 42],
            [43, 44, 45, 46, 47, 48],
        ]
print(spiral_traversal(grid_8x6))
expected = [
            (0, 0),
            (0, 1),
            (0, 2),
            (0, 3),
            (0, 4),
            (0, 5),
            (1, 5),
            (2, 5),
            (3, 5),
            (4, 5),
            (5, 5),
            (6, 5),
            (7, 5),
            (7, 4),
            (7, 3),
            (7, 2),
            (7, 1),
            (7, 0),
            (6, 0),
            (5, 0),
            (4, 0),
            (3, 0),
            (2, 0),
            (1, 0),
            (1, 1),
            (1, 2),
            (1, 3),
            (1, 4),
            (2, 4),
            (3, 4),
            (4, 4),
            (5, 4),
            (6, 4),
            (6, 3),
            (6, 2),
            (6, 1),
            (5, 1),
            (4, 1),
            (3, 1),
            (2, 1),
            (2, 2),
            (2, 3),
            (3, 3),
            (4, 3),
            (5, 3),
            (5, 2),
            (4, 2),
            (3, 2),
        ]